<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="../../css/estilos.css">
</head>
    <body>
        <div class="container">
            <div class="slide">
                <h2>¿Qué es una imagen digital?</h2>
                <p>Una imagen digital es una matriz de píxeles que representan información visual.</p>
                <p>Ejemplo: crear una imagen negra de 100x100 píxeles en NumPy.</p>
                <pre><code>import numpy as np
import matplotlib.pyplot as plt
img = np.zeros((100, 100, 3), dtype=np.uint8)
# Mostrar la imagen
plt.imshow(img)
plt.show()
</code></pre>
              </div>

              <div class="slide" data-title="Gradiente en blanco y negro">
  <h2>Gradiente en blanco y negro</h2>
  <p>
    En este ejemplo se genera una imagen de 200x200 píxeles donde cada fila tiene
    un valor creciente entre 0 y 255. El resultado es un gradiente lineal en
    escala de grises.
  </p>
  <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

# Tamaño de la imagen
w, h = 200, 200
img = np.zeros((h, w), dtype=np.uint8)

# Crear un gradiente lineal (0 a 255)
for i in range(h):
    img[i, :] = i

plt.imshow(img, cmap="gray")
plt.title("Gradiente en blanco y negro")
plt.show()
  </code></pre>
</div>

<div class="slide" data-title="Patrón senoidal">
  <h2>Patrón con seno y coseno</h2>
  <p>
    Usando funciones matemáticas como <code>sin</code> y <code>cos</code>,
    se pueden generar patrones visuales. Aquí se combinan ondas senoidales y
    cosenoidales para crear un efecto tipo "ondas de calor".
  </p>
  <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

w, h = 300, 300
x = np.linspace(0, 4*np.pi, w)
y = np.linspace(0, 4*np.pi, h)
X, Y = np.meshgrid(x, y)

# Fórmula con seno y coseno
Z = np.sin(X) + np.cos(Y)

plt.imshow(Z, cmap="plasma")
plt.title("Patrón senoidal")
plt.colorbar()
plt.show()
  </code></pre>
</div>

<div class="slide" data-title="Círculo en RGB">
  <h2>Círculo en RGB</h2>
  <p>
    Aquí se crea un lienzo en negro de 300x300 píxeles. Con una máscara
    matemática se dibuja un círculo y se colorea en rojo (RGB: 255,0,0).
  </p>
  <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

w, h = 300, 300
img = np.zeros((h, w, 3), dtype=np.uint8)

x = np.arange(w)
y = np.arange(h)
X, Y = np.meshgrid(x, y)

# Centro
cx, cy = w//2, h//2
r = 100

# Máscara del círculo
mask = (X-cx)**2 + (Y-cy)**2 < r**2

# Colorear el círculo de rojo
img[mask] = [255, 0, 0]

plt.imshow(img)
plt.title("Círculo Rojo")
plt.show()
  </code></pre>
</div>

<div class="slide" data-title="Interferencia tipo Moiré">
  <h2>Interferencia (patrón tipo Moiré)</h2>
  <p>
    Combinando ondas senoidales en 2D se pueden generar patrones de
    interferencia conocidos como <i>moiré</i>. Son muy usados en arte
    digital y simulaciones físicas.
  </p>
  <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

w, h = 300, 300
x = np.linspace(0, 10*np.pi, w)
y = np.linspace(0, 10*np.pi, h)
X, Y = np.meshgrid(x, y)

# Fórmula de interferencia
Z = np.sin(X) * np.sin(Y)

plt.imshow(Z, cmap="inferno")
plt.title("Interferencia tipo Moiré")
plt.show()
  </code></pre>
</div>

<div class="slide" data-title="Espiral logarítmica">
  <h2>Espiral logarítmica</h2>
  <p>
    Una espiral logarítmica se genera usando coordenadas polares. Este tipo de espirales
    aparece en la naturaleza (conchas, galaxias, flores). La intensidad depende del ángulo
    y la distancia al centro.
  </p>
  <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

w, h = 400, 400
x = np.linspace(-2, 2, w)
y = np.linspace(-2, 2, h)
X, Y = np.meshgrid(x, y)

# Convertir a coordenadas polares
R = np.sqrt(X**2 + Y**2)
Theta = np.arctan2(Y, X)

# Fórmula de espiral
Z = np.sin(10 * np.log(R + 1e-5) + 5 * Theta)

plt.imshow(Z, cmap="twilight", extent=(-2,2,-2,2))
plt.title("Espiral logarítmica")
plt.show()
  </code></pre>
</div>

<div class="slide" data-title="Fractal de Mandelbrot">
  <h2>Fractal de Mandelbrot</h2>
  <p>
    El conjunto de Mandelbrot es uno de los fractales más famosos. Se genera 
    iterando la fórmula <code>z = z^2 + c</code> en el plano complejo y 
    coloreando según el número de iteraciones antes de divergir.
  </p>
  <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

w, h = 500, 500
max_iter = 100

# Rango del plano complejo
x = np.linspace(-2, 1, w)
y = np.linspace(-1.5, 1.5, h)
X, Y = np.meshgrid(x, y)
C = X + 1j * Y
Z = np.zeros_like(C)
img = np.zeros(C.shape, dtype=int)

for i in range(max_iter):
    mask = np.abs(Z) <= 2
    Z[mask] = Z[mask]**2 + C[mask]
    img[mask] = i

plt.imshow(img, cmap="hot", extent=(-2,1,-1.5,1.5))
plt.title("Fractal de Mandelbrot")
plt.show()
  </code></pre>
</div>

<div class="slide" data-title="Fractal de Julia">
  <h2>Fractal de Julia</h2>
  <p>
    Similar al conjunto de Mandelbrot, el fractal de Julia se genera iterando 
    <code>z = z^2 + c</code> pero con un valor fijo de <code>c</code>. 
    Dependiendo del valor de <code>c</code>, se obtienen diferentes figuras.
  </p>
  <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

w, h = 500, 500
max_iter = 200
c = complex(-0.7, 0.27015)

x = np.linspace(-1.5, 1.5, w)
y = np.linspace(-1.5, 1.5, h)
X, Y = np.meshgrid(x, y)
Z = X + 1j * Y

img = np.zeros(Z.shape, dtype=int)

for i in range(max_iter):
    mask = np.abs(Z) <= 2
    Z[mask] = Z[mask]**2 + c
    img[mask] = i

plt.imshow(img, cmap="inferno", extent=(-1.5,1.5,-1.5,1.5))
plt.title("Fractal de Julia")
plt.show()
  </code></pre>
</div>

<div class="slide" data-title="Ruido Perlin simulado">
  <h2>Ruido Perlin (simulado)</h2>
  <p>
    El ruido Perlin es usado en gráficos por computadora para generar texturas 
    naturales (nubes, fuego, terreno). Aquí se simula con sumas de ondas senoidales.
  </p>
  <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

w, h = 400, 400
x = np.linspace(0, 5*np.pi, w)
y = np.linspace(0, 5*np.pi, h)
X, Y = np.meshgrid(x, y)

# Simulación de ruido con senos y cosenos
Z = (np.sin(X) + np.cos(Y) + np.sin(X+Y) + np.cos(X-Y))

plt.imshow(Z, cmap="terrain")
plt.title("Ruido Perlin simulado")
plt.show()
  </code></pre>
</div>

              
              <div class="slide">
                <h2>Espacios de color: RGB</h2>
                <p>El espacio RGB representa los colores mediante combinaciones de rojo, verde y azul.</p>
                <pre><code>from PIL import Image
import matplotlib.pyplot as plt
img = Image.open("foto.jpg")
r, g, b = img.split()
plt.imshow(r)
plt.show()</code></pre>
              </div>
              
              <div class="slide">
                <h2>Espacios de color: Grayscale</h2>
                <p>Escala de grises elimina la información de color, dejando solo la intensidad.</p>
                <pre><code>from PIL import Image
gray = Image.open("foto.jpg").convert("L")
import matplotlib.pyplot as plt
plt.imshow(gray, cmap='gray')
plt.show()
            </code></pre>
              </div>
              
              <div class="slide">
                <h2>Espacios de color: HSV</h2>
                <p>HSV separa la tonalidad (H), saturación (S) y valor (V).</p>
                <pre><code>import cv2
img = cv2.imread("foto.jpg")
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
import matplotlib.pyplot as plt
plt.imshow(img)
plt.show()</code></pre>
              </div>
              
              <div class="slide">
                <h2>Operaciones básicas: Redimensionar</h2>
                <p>Redimensionar cambia el tamaño de la imagen.</p>
                <pre><code>from PIL import Image
img = Image.open("foto.jpg")
resized = img.resize((200, 200))
import matplotlib.pyplot as plt
plt.imshow(resized)
plt.show()</code></pre>
              </div>
              
              <div class="slide">
                <h2>Operaciones básicas: Recortar</h2>
                <p>Recortar selecciona una región de interés.</p>
                <pre><code>box = (50, 50, 150, 150)
cropped = img.crop(box)
import matplotlib.pyplot as plt
plt.imshow(cropped)
plt.show()</code></pre>
              </div>
              
              <div class="slide">
                <h2>Operaciones básicas: Normalizar</h2>
                <p>Normalizar escala los valores de píxel, útil para modelos de IA.</p>
                <pre><code>import numpy as np
img_array = np.array(img) / 255.0
import matplotlib.pyplot as plt
plt.imshow(img_array)
plt.show()</code></pre>
              </div>
              
              <div class="slide">
                <h2>Librerías: PIL (Pillow)</h2>
                <p>Pillow facilita tareas básicas de procesamiento de imágenes.</p>
                <pre><code>from PIL import Image, ImageFilter
img = Image.open("foto.jpg")
blurred = img.filter(ImageFilter.BLUR)
import matplotlib.pyplot as plt
plt.imshow(blurred)
plt.show()</code></pre>
              </div>
              
              <div class="slide">
                <h2>Librerías: OpenCV</h2>
                <p>OpenCV es potente para visión por computador en tiempo real.</p>
                <pre><code>import cv2
img = cv2.imread("foto.jpg")
edges = cv2.Canny(img, 100, 200)
import matplotlib.pyplot as plt
plt.imshow(edges)
plt.show()</code></pre>
              </div>
              
              <div class="slide">
                <h2>Librerías: TensorFlow Image</h2>
                <p>TensorFlow tiene herramientas para preprocesamiento eficiente.</p>
                <pre><code>import tensorflow as tf
img = tf.io.read_file("foto.jpg")
img = tf.image.decode_jpeg(img, channels=3)
img = tf.image.resize(img, [224, 224])
img = img / 255.0
import matplotlib.pyplot as plt
plt.imshow(img)
plt.show()</code></pre>
              </div>
              

        <div class="nav">
            <button onclick="prevSlide()">Anterior</button>
            <button onclick="nextSlide()">Siguiente</button>
        </div>
    </div>
    <script src="../../js/slide.js"></script>
    </body>
</html>
