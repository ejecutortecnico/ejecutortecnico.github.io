<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Orientado a Objetos</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="../../css/estilos.css">
</head>
<body>
    <div class="container">
        <!-- Slide 1 -->
        <div class="slide active">
            <h1>Python Orientado a Objetos</h1>
            <h2>Introducción a los Conceptos Básicos</h2>
            <p>Exploraremos los fundamentos de la programación orientada a objetos (OOP) en Python, incluyendo clases, objetos, herencia y más.</p>
        </div>

        <!-- Slide 2: Clases y Objetos -->
        <div class="slide hidden">
            <h2>1. Clases y Objetos</h2>
            <p>Una clase es una plantilla para crear objetos (instancias), mientras que un objeto es una instancia de una clase.</p>
            <pre><code>class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def saludar(self):
        return f"Hola, soy {self.nombre} y tengo {self.edad} años."

# Crear un objeto
persona1 = Persona("Ana", 25)
print(persona1.saludar())  # Salida: Hola, soy Ana y tengo 25 años
</code></pre>
        </div>

        <!-- Slide 3: Encapsulamiento -->
        <div class="slide hidden">
            <h2>2. Encapsulamiento</h2>
            <p>El encapsulamiento permite restringir el acceso directo a los datos modificándolos a través de métodos.</p>
            <pre><code>class CuentaBancaria:
    def __init__(self, balance):
        self.__balance = balance  # Variable privada

    def depositar(self, monto):
        self.__balance += monto

    def get_balance(self):
        return self.__balance

cuenta = CuentaBancaria(1000)
cuenta.depositar(500)
print(cuenta.get_balance())  # Salida: 1500
</code></pre>
        </div>

        <!-- Slide 4: Herencia -->
        <div class="slide hidden">
            <h2>3. Herencia</h2>
            <p>La herencia permite que una clase hija herede los atributos y métodos de una clase padre.</p>
            <pre><code>class Animal:
    def hablar(self):
        return "Sonido de animal"

class Perro(Animal):
    def hablar(self):
        return "Guau!"

class Gato(Animal):
    def hablar(self):
        return "Miau!"

animales = [Perro(), Gato()]
for animal in animales:
    print(animal.hablar())  # Salida: Guau! Miau!
</code></pre>
        </div>

        <!-- Slide 5: Polimorfismo -->
        <div class="slide hidden">
            <h2>4. Polimorfismo</h2>
            <p>El polimorfismo permite que diferentes clases usen el mismo método de forma distinta.</p>
            <pre><code>class Vehiculo:
    def mover(self):
        pass

class Coche(Vehiculo):
    def mover(self):
        return "El coche se mueve en la carretera."

class Barco(Vehiculo):
    def mover(self):
        return "El barco navega en el agua."

vehiculos = [Coche(), Barco()]
for vehiculo in vehiculos:
    print(vehiculo.mover())
# Salida: El coche se mueve en la carretera.
#         El barco navega en el agua.
</code></pre>
        </div>

        <!-- Slide 6: Abstracción -->
        <div class="slide hidden">
            <h2>5. Abstracción</h2>
            <p>La abstracción permite ocultar los detalles complejos de una función, presentando solo lo esencial.</p>
            <pre><code>from abc import ABC, abstractmethod

class Ave(ABC):
    @abstractmethod
    def volar(self):
        pass

class Aguila(Ave):
    def volar(self):
        return "El águila vuela alto!"

class Pinguino(Ave):
    def volar(self):
        return "El pingüino no vuela, nada."

aves = [Aguila(), Pinguino()]
for ave in aves:
    print(ave.volar())
# Salida: El águila vuela alto!
#         El pingüino no vuela, nada.
</code></pre>
        </div>

        <!-- Slide 7: Métodos Especiales -->
        <div class="slide hidden">
            <h2>6. Métodos Especiales</h2>
            <p>Python tiene métodos especiales como `__str__` y `__repr__`, que controlan cómo se muestra el objeto cuando se imprime.</p>
            <pre><code>class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def __str__(self):
        return f"{self.nombre}, {self.edad} años"

persona1 = Persona("Carlos", 30)
print(persona1)  # Salida: Carlos, 30 años
</code></pre>
        </div>

        <!-- Slide 8: Conclusión -->
        <div class="slide hidden">
            <h2>Conclusión</h2>
            <p>La programación orientada a objetos en Python permite crear aplicaciones organizadas y reutilizables. Con estos conceptos, es posible construir programas más complejos y mantenibles.</p>
        </div>

        <!-- Navigation Buttons -->
        <div class="nav">
            <button onclick="previousSlide()">Anterior</button>
            <button onclick="nextSlide()">Siguiente</button>
        </div>
    </div>

     <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll(".slide");

        function showSlide(index) {
            slides.forEach((slide, i) => {
                slide.classList.toggle("active", i === index);
            });
        }

        function nextSlide() {
            currentSlide = (currentSlide + 1) % slides.length;
            showSlide(currentSlide);
        }

        function prevSlide() {
            currentSlide = (currentSlide - 1 + slides.length) % slides.length;
            showSlide(currentSlide);
        }

        showSlide(currentSlide);
    </script>
</body>
</html>
